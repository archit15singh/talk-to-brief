# Transcript
Audio: data/audio/sample.mp3
Language: en (confidence: 1.00)
Duration: 894.60s

[00:14 -> 00:22] Welcome everyone. I'm going to talk about practical tactics to build reliable AI applications.
  00:14-00:15:  Welcome
  00:15-00:16:  everyone.
  00:17-00:18:  I'm
  00:18-00:18:  going
  00:18-00:18:  to
  00:18-00:18:  talk
  00:18-00:18:  about
  00:18-00:19:  practical
  00:19-00:19:  tactics
  00:19-00:19:  to
  00:19-00:20:  build
  00:20-00:21:  reliable
  00:21-00:22:  AI
  00:22-00:22:  applications.

[00:22 -> 00:30] And why nobody does it this way yet? A little bit about myself or why you should trust me.
  00:22-00:23:  And
  00:23-00:23:  why
  00:23-00:24:  nobody
  00:24-00:24:  does
  00:24-00:24:  it
  00:24-00:25:  this
  00:25-00:25:  way
  00:25-00:25:  yet?
  00:26-00:27:  A
  00:27-00:27:  little
  00:27-00:27:  bit
  00:27-00:28:  about
  00:28-00:28:  myself
  00:28-00:28:  or
  00:28-00:29:  why
  00:29-00:29:  you
  00:29-00:29:  should
  00:29-00:29:  trust
  00:29-00:30:  me.

[00:31 -> 00:39] I've allowed 15 years as a startup co-founder and CEO. I held executive positions for the last five
  00:31-00:31:  I've
  00:31-00:32:  allowed
  00:32-00:32:  15
  00:32-00:32:  years
  00:32-00:33:  as
  00:33-00:33:  a
  00:33-00:33:  startup
  00:33-00:34:  co
  00:34-00:34: -founder
  00:34-00:34:  and
  00:34-00:35:  CEO.
  00:35-00:36:  I
  00:36-00:36:  held
  00:36-00:37:  executive
  00:37-00:38:  positions
  00:38-00:38:  for
  00:38-00:38:  the
  00:38-00:38:  last
  00:38-00:39:  five

[00:39 -> 00:47] years at several enterprises. But most importantly, I spent last couple of years developing a lot of
  00:39-00:39:  years
  00:39-00:39:  at
  00:39-00:40:  several
  00:40-00:41:  enterprises.
  00:42-00:42:  But
  00:42-00:42:  most
  00:42-00:42:  importantly,
  00:43-00:43:  I
  00:43-00:43:  spent
  00:43-00:43:  last
  00:43-00:44:  couple
  00:44-00:44:  of
  00:44-00:44:  years
  00:44-00:45:  developing
  00:45-00:46:  a
  00:46-00:46:  lot
  00:46-00:47:  of

[00:47 -> 00:58] GNI projects, ranging from POCs to many production level solutions and helped some companies to get it done.
  00:47-00:47:  GNI
  00:47-00:48:  projects,
  00:48-00:48:  ranging
  00:48-00:49:  from
  00:49-00:49:  POCs
  00:49-00:50:  to
  00:50-00:51:  many
  00:51-00:52:  production
  00:52-00:52:  level
  00:52-00:54:  solutions
  00:54-00:55:  and
  00:55-00:55:  helped
  00:55-00:56:  some
  00:56-00:57:  companies
  00:57-00:57:  to
  00:57-00:57:  get
  00:57-00:57:  it
  00:57-00:58:  done.

[00:59 -> 01:09] And I've learned or distilled a way to make these applications reliable. And there are quite a lot of
  00:59-00:59:  And
  00:59-01:00:  I've
  01:00-01:00:  learned
  01:00-01:01:  or
  01:01-01:02:  distilled
  01:02-01:02:  a
  01:02-01:02:  way
  01:02-01:02:  to
  01:02-01:03:  make
  01:03-01:04:  these
  01:04-01:04:  applications
  01:04-01:05:  reliable.
  01:06-01:06:  And
  01:06-01:07:  there
  01:07-01:08:  are
  01:08-01:08:  quite
  01:08-01:08:  a
  01:08-01:08:  lot
  01:08-01:09:  of

[01:09 -> 01:21] trucks, this conference about evils and reliability. But to my surprise nobody was talking about the most important things.
  01:09-01:09:  trucks,
  01:10-01:10:  this
  01:10-01:13:  conference
  01:13-01:13:  about
  01:13-01:14:  evils
  01:14-01:14:  and
  01:14-01:15:  reliability.
  01:15-01:15:  But
  01:15-01:16:  to
  01:16-01:16:  my
  01:16-01:17:  surprise
  01:17-01:18:  nobody
  01:18-01:19:  was
  01:19-01:19:  talking
  01:19-01:19:  about
  01:19-01:20:  the
  01:20-01:20:  most
  01:20-01:21:  important
  01:21-01:21:  things.

[01:22 -> 01:33] And we're going to talk about it right now. So, standard software development lifecycle is a very standard simple.
  01:22-01:22:  And
  01:22-01:23:  we're
  01:23-01:23:  going
  01:23-01:23:  to
  01:23-01:23:  talk
  01:23-01:23:  about
  01:23-01:24:  it
  01:24-01:24:  right
  01:24-01:24:  now.
  01:26-01:26:  So,
  01:27-01:27:  standard
  01:27-01:28:  software
  01:28-01:28:  development
  01:28-01:28:  lifecycle
  01:28-01:29:  is
  01:29-01:30:  a
  01:30-01:30:  very
  01:30-01:31:  standard
  01:31-01:33:  simple.

[01:33 -> 01:44] You design your solution, you develop it, you test it, and then eventually you deploy it. And when people start doing POC with AI,
  01:33-01:33:  You
  01:33-01:34:  design
  01:34-01:34:  your
  01:34-01:35:  solution,
  01:35-01:35:  you
  01:35-01:35:  develop
  01:35-01:35:  it,
  01:36-01:36:  you
  01:36-01:36:  test
  01:36-01:36:  it,
  01:36-01:36:  and
  01:36-01:36:  then
  01:36-01:37:  eventually
  01:37-01:37:  you
  01:37-01:37:  deploy
  01:37-01:38:  it.
  01:38-01:39:  And
  01:39-01:40:  when
  01:40-01:40:  people
  01:40-01:41:  start
  01:41-01:41:  doing
  01:41-01:43:  POC
  01:43-01:43:  with
  01:43-01:44:  AI,

[01:45 -> 01:57] it sounds simple. You can very easily do some prompt and models are very capable. But then you start facing some unexpected challenges.
  01:45-01:45:  it
  01:45-01:46:  sounds
  01:46-01:46:  simple.
  01:47-01:47:  You
  01:47-01:47:  can
  01:47-01:48:  very
  01:48-01:48:  easily
  01:48-01:49:  do
  01:49-01:49:  some
  01:49-01:50:  prompt
  01:50-01:50:  and
  01:50-01:51:  models
  01:51-01:51:  are
  01:51-01:51:  very
  01:51-01:52:  capable.
  01:53-01:53:  But
  01:53-01:53:  then
  01:53-01:54:  you
  01:54-01:54:  start
  01:54-01:55:  facing
  01:55-01:55:  some
  01:55-01:56:  unexpected
  01:56-01:57:  challenges.

[01:59 -> 02:13] Actually, you can easily do a POC that works 50% of the time. But making it do the same reliable work, the rest of the 50% is very hard, because models are non-deterministic.
  01:59-01:59:  Actually,
  02:00-02:00:  you
  02:00-02:00:  can
  02:00-02:01:  easily
  02:01-02:01:  do
  02:01-02:01:  a
  02:01-02:01:  POC
  02:01-02:02:  that
  02:02-02:02:  works
  02:02-02:02:  50
  02:02-02:03: %
  02:03-02:03:  of
  02:03-02:03:  the
  02:03-02:03:  time.
  02:04-02:04:  But
  02:04-02:05:  making
  02:05-02:05:  it
  02:05-02:06:  do
  02:06-02:06:  the
  02:06-02:06:  same
  02:06-02:07:  reliable
  02:07-02:07:  work,
  02:08-02:08:  the
  02:08-02:08:  rest
  02:08-02:08:  of
  02:08-02:08:  the
  02:08-02:09:  50
  02:09-02:09: %
  02:09-02:09:  is
  02:09-02:10:  very
  02:10-02:11:  hard,
  02:11-02:11:  because
  02:11-02:12:  models
  02:12-02:12:  are
  02:12-02:13:  non
  02:13-02:13: -deterministic.

[02:14 -> 02:25] And it starts requiring a data science approach, continuous experimentation. You need to try this prompt, you need to try that model, you need to try this approach, etc, etc.
  02:14-02:15:  And
  02:15-02:15:  it
  02:15-02:16:  starts
  02:16-02:16:  requiring
  02:16-02:18:  a
  02:18-02:18:  data
  02:18-02:18:  science
  02:18-02:18:  approach,
  02:19-02:20:  continuous
  02:20-02:20:  experimentation.
  02:21-02:21:  You
  02:21-02:21:  need
  02:21-02:21:  to
  02:21-02:21:  try
  02:21-02:21:  this
  02:21-02:22:  prompt,
  02:22-02:22:  you
  02:22-02:22:  need
  02:22-02:22:  to
  02:22-02:22:  try
  02:22-02:23:  that
  02:23-02:23:  model,
  02:23-02:23:  you
  02:23-02:23:  need
  02:23-02:23:  to
  02:23-02:24:  try
  02:24-02:24:  this
  02:24-02:24:  approach,
  02:24-02:25:  etc,
  02:25-02:25:  etc.

[02:25 -> 02:39] And everything in your solution, everything that represents your solution, which is your code, your logic, the prompt, the models that you use, the data that you base your solution on.
  02:25-02:26:  And
  02:26-02:28:  everything
  02:28-02:29:  in
  02:29-02:29:  your
  02:29-02:29:  solution,
  02:29-02:30:  everything
  02:30-02:30:  that
  02:30-02:31:  represents
  02:31-02:31:  your
  02:31-02:32:  solution,
  02:32-02:32:  which
  02:32-02:32:  is
  02:32-02:32:  your
  02:32-02:33:  code,
  02:33-02:33:  your
  02:33-02:33:  logic,
  02:34-02:34:  the
  02:34-02:35:  prompt,
  02:35-02:35:  the
  02:35-02:36:  models
  02:36-02:36:  that
  02:36-02:36:  you
  02:36-02:37:  use,
  02:37-02:37:  the
  02:37-02:37:  data
  02:37-02:38:  that
  02:38-02:38:  you
  02:38-02:38:  base
  02:38-02:38:  your
  02:38-02:39:  solution
  02:39-02:39:  on.

[02:40 -> 02:46] Changing anything of that impacts your solution in unexpected ways.
  02:40-02:40:  Changing
  02:40-02:41:  anything
  02:41-02:42:  of
  02:42-02:42:  that
  02:42-02:42:  impacts
  02:42-02:43:  your
  02:43-02:44:  solution
  02:44-02:44:  in
  02:44-02:45:  unexpected
  02:45-02:46:  ways.

[02:50 -> 03:01] People often come to this, to try solving this with the wrong approach. They start with data science metrics.
  02:50-02:51:  People
  02:51-02:52:  often
  02:52-02:52:  come
  02:52-02:52:  to
  02:52-02:53:  this,
  02:53-02:54:  to
  02:54-02:55:  try
  02:55-02:55:  solving
  02:55-02:56:  this
  02:56-02:56:  with
  02:56-02:57:  the
  02:57-02:57:  wrong
  02:57-02:57:  approach.
  02:58-02:58:  They
  02:58-02:59:  start
  02:59-02:59:  with
  02:59-03:00:  data
  03:00-03:00:  science
  03:00-03:01:  metrics.

[03:01 -> 03:21] It sounds reasonable, so it requires data science approach of the experimentation, and people start measuring groundness, factuality, bias, and other metrics that don't really help you to understand is your solution working the right way.
  03:01-03:01:  It
  03:01-03:03:  sounds
  03:03-03:04:  reasonable,
  03:04-03:04:  so
  03:04-03:04:  it
  03:04-03:05:  requires
  03:05-03:05:  data
  03:05-03:05:  science
  03:05-03:06:  approach
  03:06-03:06:  of
  03:06-03:06:  the
  03:06-03:06:  experimentation,
  03:07-03:07:  and
  03:07-03:08:  people
  03:08-03:08:  start
  03:08-03:09:  measuring
  03:09-03:10:  groundness,
  03:10-03:11:  factuality,
  03:11-03:11:  bias,
  03:12-03:12:  and
  03:12-03:12:  other
  03:12-03:14:  metrics
  03:14-03:14:  that
  03:14-03:15:  don't
  03:15-03:15:  really
  03:15-03:16:  help
  03:16-03:16:  you
  03:16-03:16:  to
  03:16-03:17:  understand
  03:17-03:18:  is
  03:18-03:19:  your
  03:19-03:19:  solution
  03:19-03:20:  working
  03:20-03:21:  the
  03:21-03:21:  right
  03:21-03:21:  way.

[03:21 -> 03:29] Does your latest change improve your solution in the right way, for your users?
  03:21-03:22:  Does
  03:22-03:23:  your
  03:23-03:24:  latest
  03:24-03:24:  change
  03:24-03:26:  improve
  03:26-03:27:  your
  03:27-03:27:  solution
  03:27-03:28:  in
  03:28-03:28:  the
  03:28-03:28:  right
  03:28-03:28:  way,
  03:28-03:28:  for
  03:28-03:28:  your
  03:28-03:29:  users?

[03:30 -> 03:39] For example, I've been talking to an ex colleague that are building a customer support boat at weeks. I asked him, how do you know that your solution is working well?
  03:30-03:30:  For
  03:30-03:31:  example,
  03:31-03:31:  I've
  03:31-03:31:  been
  03:31-03:31:  talking
  03:31-03:32:  to
  03:32-03:32:  an
  03:32-03:33:  ex
  03:33-03:33:  colleague
  03:33-03:33:  that
  03:33-03:34:  are
  03:34-03:34:  building
  03:34-03:34:  a
  03:34-03:34:  customer
  03:34-03:35:  support
  03:35-03:35:  boat
  03:35-03:35:  at
  03:35-03:35:  weeks.
  03:36-03:36:  I
  03:36-03:37:  asked
  03:37-03:37:  him,
  03:37-03:37:  how
  03:37-03:37:  do
  03:37-03:37:  you
  03:37-03:38:  know
  03:38-03:38:  that
  03:38-03:38:  your
  03:38-03:39:  solution
  03:39-03:39:  is
  03:39-03:39:  working
  03:39-03:39:  well?

[03:40 -> 03:44] He started talking about factuality and other data science metrics.
  03:40-03:40:  He
  03:40-03:41:  started
  03:41-03:41:  talking
  03:41-03:41:  about
  03:41-03:42:  factuality
  03:42-03:42:  and
  03:42-03:43:  other
  03:43-03:43:  data
  03:43-03:43:  science
  03:43-03:44:  metrics.

[03:46 -> 04:02] That's again, I started to dig deeper, and then we just together figure out that the most important metric for them is the rate of moving from AI support boat, like escalation to human support.
  03:46-03:47:  That's
  03:47-03:47:  again,
  03:47-03:47:  I
  03:47-03:48:  started
  03:48-03:48:  to
  03:48-03:48:  dig
  03:48-03:48:  deeper,
  03:49-03:49:  and
  03:49-03:49:  then
  03:49-03:49:  we
  03:49-03:50:  just
  03:50-03:51:  together
  03:51-03:51:  figure
  03:51-03:52:  out
  03:52-03:52:  that
  03:52-03:52:  the
  03:52-03:52:  most
  03:52-03:53:  important
  03:53-03:53:  metric
  03:53-03:53:  for
  03:53-03:53:  them
  03:53-03:54:  is
  03:54-03:56:  the
  03:56-03:56:  rate
  03:56-03:57:  of
  03:57-03:57:  moving
  03:57-03:58:  from
  03:58-03:59:  AI
  03:59-03:59:  support
  03:59-04:00:  boat,
  04:00-04:00:  like
  04:00-04:01:  escalation
  04:01-04:01:  to
  04:01-04:01:  human
  04:01-04:02:  support.

[04:03 -> 04:17] If your solution hasn't able to answer the user with all this factuality, it could be super grounded, but still not provide the right answer that the user expects, and this is what you actually need to test.
  04:03-04:03:  If
  04:03-04:04:  your
  04:04-04:04:  solution
  04:04-04:05:  hasn't
  04:05-04:06:  able
  04:06-04:06:  to
  04:06-04:06:  answer
  04:06-04:07:  the
  04:07-04:07:  user
  04:07-04:08:  with
  04:08-04:08:  all
  04:08-04:08:  this
  04:08-04:09:  factuality,
  04:09-04:10:  it
  04:10-04:10:  could
  04:10-04:10:  be
  04:10-04:10:  super
  04:10-04:11:  grounded,
  04:11-04:11:  but
  04:11-04:11:  still
  04:11-04:11:  not
  04:11-04:12:  provide
  04:12-04:12:  the
  04:12-04:12:  right
  04:12-04:13:  answer
  04:13-04:14:  that
  04:14-04:14:  the
  04:14-04:14:  user
  04:14-04:15:  expects,
  04:15-04:15:  and
  04:15-04:16:  this
  04:16-04:16:  is
  04:16-04:16:  what
  04:16-04:16:  you
  04:16-04:17:  actually
  04:17-04:17:  need
  04:17-04:17:  to
  04:17-04:17:  test.

[04:21 -> 04:41] My experience was to start with real-world scenarios. You need to reverse engineer your metrics, and your metrics should be very specific to what your end goal should come from a product experience from business outcomes.
  04:21-04:22:  My
  04:22-04:23:  experience
  04:23-04:23:  was
  04:23-04:24:  to
  04:24-04:25:  start
  04:25-04:25:  with
  04:25-04:26:  real
  04:26-04:26: -world
  04:26-04:27:  scenarios.
  04:27-04:28:  You
  04:28-04:28:  need
  04:28-04:28:  to
  04:28-04:28:  reverse
  04:28-04:29:  engineer
  04:29-04:30:  your
  04:30-04:30:  metrics,
  04:30-04:31:  and
  04:31-04:31:  your
  04:31-04:31:  metrics
  04:31-04:32:  should
  04:32-04:32:  be
  04:32-04:33:  very
  04:33-04:34:  specific
  04:34-04:34:  to
  04:34-04:35:  what
  04:35-04:35:  your
  04:35-04:36:  end
  04:36-04:36:  goal
  04:36-04:36:  should
  04:36-04:37:  come
  04:37-04:38:  from
  04:38-04:38:  a
  04:38-04:39:  product
  04:39-04:39:  experience
  04:39-04:40:  from
  04:40-04:40:  business
  04:40-04:41:  outcomes.

[04:41 -> 04:48] If your solution is customer support boat, you need to figure out what your users want and how you can mimic it.
  04:41-04:41:  If
  04:41-04:43:  your
  04:43-04:43:  solution
  04:43-04:43:  is
  04:43-04:43:  customer
  04:43-04:44:  support
  04:44-04:44:  boat,
  04:44-04:44:  you
  04:44-04:44:  need
  04:44-04:44:  to
  04:44-04:44:  figure
  04:44-04:45:  out
  04:45-04:45:  what
  04:45-04:45:  your
  04:45-04:46:  users
  04:46-04:46:  want
  04:46-04:47:  and
  04:47-04:47:  how
  04:47-04:47:  you
  04:47-04:47:  can
  04:47-04:48:  mimic
  04:48-04:48:  it.

[04:49 -> 05:01] Instead of measuring something average or something generic, you need to measure a very specific criteria, because universal evolves don't really work.
  04:49-04:50:  Instead
  04:50-04:50:  of
  04:50-04:51:  measuring
  04:51-04:51:  something
  04:51-04:52:  average
  04:52-04:53:  or
  04:53-04:53:  something
  04:53-04:54:  generic,
  04:54-04:54:  you
  04:54-04:55:  need
  04:55-04:55:  to
  04:55-04:55:  measure
  04:55-04:55:  a
  04:55-04:56:  very
  04:56-04:56:  specific
  04:56-04:57:  criteria,
  04:58-04:59:  because
  04:59-04:59:  universal
  04:59-05:00:  evolves
  05:00-05:00:  don't
  05:00-05:00:  really
  05:00-05:01:  work.

[05:01 -> 05:11] How do we do it? For example, customer support boat, which is by way one of the hardest things to do evolves properly.
  05:01-05:01:  How
  05:01-05:03:  do
  05:03-05:03:  we
  05:03-05:03:  do
  05:03-05:04:  it?
  05:05-05:05:  For
  05:05-05:05:  example,
  05:06-05:06:  customer
  05:06-05:06:  support
  05:06-05:07:  boat,
  05:07-05:07:  which
  05:07-05:07:  is
  05:07-05:07:  by
  05:07-05:07:  way
  05:07-05:08:  one
  05:08-05:08:  of
  05:08-05:08:  the
  05:08-05:08:  hardest
  05:08-05:10:  things
  05:10-05:10:  to
  05:10-05:10:  do
  05:10-05:11:  evolves
  05:11-05:11:  properly.

[05:12 -> 05:22] Let's say I have a bank, and a bank has FAQ materials, which contain, including how do you reset your password?
  05:12-05:13:  Let's
  05:13-05:13:  say
  05:13-05:13:  I
  05:13-05:13:  have
  05:13-05:14:  a
  05:14-05:14:  bank,
  05:14-05:15:  and
  05:15-05:15:  a
  05:15-05:15:  bank
  05:15-05:16:  has
  05:16-05:17:  FAQ
  05:17-05:17:  materials,
  05:18-05:19:  which
  05:19-05:19:  contain,
  05:19-05:20:  including
  05:20-05:20:  how
  05:20-05:20:  do
  05:20-05:21:  you
  05:21-05:21:  reset
  05:21-05:21:  your
  05:21-05:22:  password?

[05:24 -> 05:37] What I usually do when I help my companies with help them to build AI solutions, we start with reverse engineering, like how do we create VALs based on that?
  05:24-05:25:  What
  05:25-05:25:  I
  05:25-05:26:  usually
  05:26-05:26:  do
  05:26-05:27:  when
  05:27-05:27:  I
  05:27-05:27:  help
  05:27-05:27:  my
  05:27-05:28:  companies
  05:28-05:29:  with
  05:29-05:29:  help
  05:29-05:30:  them
  05:30-05:30:  to
  05:30-05:30:  build
  05:30-05:31:  AI
  05:31-05:32:  solutions,
  05:32-05:33:  we
  05:33-05:33:  start
  05:33-05:34:  with
  05:34-05:34:  reverse
  05:34-05:35:  engineering,
  05:35-05:35:  like
  05:35-05:35:  how
  05:35-05:36:  do
  05:36-05:36:  we
  05:36-05:36:  create
  05:36-05:36:  VALs
  05:36-05:37:  based
  05:37-05:37:  on
  05:37-05:37:  that?

[05:37 -> 05:44] In this case, I use LLM, and in most cases I use LLM, to come up with right evaluations.
  05:37-05:38:  In
  05:38-05:38:  this
  05:38-05:38:  case,
  05:39-05:39:  I
  05:39-05:39:  use
  05:39-05:40:  LLM,
  05:40-05:40:  and
  05:40-05:41:  in
  05:41-05:41:  most
  05:41-05:41:  cases
  05:41-05:41:  I
  05:41-05:41:  use
  05:41-05:42:  LLM,
  05:42-05:42:  to
  05:42-05:42:  come
  05:42-05:42:  up
  05:42-05:43:  with
  05:43-05:43:  right
  05:43-05:44:  evaluations.

[05:45 -> 06:04] Here I can take, say, O3 now and just reverse engineer what should be the user question that we know to answer based on these materials, and what should be the specific criteria that these materials provide an answer for?
  05:45-05:45:  Here
  05:45-05:45:  I
  05:45-05:46:  can
  05:46-05:46:  take,
  05:46-05:47:  say,
  05:47-05:48:  O3
  05:48-05:48:  now
  05:48-05:50:  and
  05:50-05:50:  just
  05:50-05:51:  reverse
  05:51-05:52:  engineer
  05:52-05:52:  what
  05:52-05:53:  should
  05:53-05:53:  be
  05:53-05:53:  the
  05:53-05:53:  user
  05:53-05:54:  question
  05:54-05:55:  that
  05:55-05:55:  we
  05:55-05:56:  know
  05:56-05:56:  to
  05:56-05:56:  answer
  05:56-05:57:  based
  05:57-05:57:  on
  05:57-05:57:  these
  05:57-05:58:  materials,
  05:58-05:58:  and
  05:58-05:59:  what
  05:59-05:59:  should
  05:59-05:59:  be
  05:59-05:59:  the
  05:59-05:59:  specific
  05:59-06:00:  criteria
  06:00-06:00:  that
  06:00-06:01:  these
  06:01-06:02:  materials
  06:02-06:03:  provide
  06:03-06:03:  an
  06:03-06:04:  answer
  06:04-06:04:  for?

[06:04 -> 06:23] Some of these criteria are quite important, so for example, here it says that as part of the thing, you need to receive a mobile validation, so you receive a SMS code, and it says that if you don't have a mobile number then you can reach support, et cetera, et cetera.
  06:04-06:05:  Some
  06:05-06:05:  of
  06:05-06:05:  these
  06:05-06:06:  criteria
  06:06-06:06:  are
  06:06-06:07:  quite
  06:07-06:07:  important,
  06:07-06:07:  so
  06:07-06:07:  for
  06:07-06:08:  example,
  06:08-06:08:  here
  06:08-06:08:  it
  06:08-06:08:  says
  06:08-06:08:  that
  06:08-06:10:  as
  06:10-06:10:  part
  06:10-06:11:  of
  06:11-06:11:  the
  06:11-06:11:  thing,
  06:12-06:12:  you
  06:12-06:12:  need
  06:12-06:12:  to
  06:12-06:13:  receive
  06:13-06:13:  a
  06:13-06:13:  mobile
  06:13-06:13:  validation,
  06:14-06:14:  so
  06:14-06:14:  you
  06:14-06:14:  receive
  06:14-06:14:  a
  06:14-06:15:  SMS
  06:15-06:15:  code,
  06:15-06:16:  and
  06:16-06:16:  it
  06:16-06:16:  says
  06:16-06:16:  that
  06:16-06:17:  if
  06:17-06:17:  you
  06:17-06:19:  don't
  06:19-06:19:  have
  06:19-06:19:  a
  06:19-06:19:  mobile
  06:19-06:20:  number
  06:20-06:20:  then
  06:20-06:20:  you
  06:20-06:20:  can
  06:20-06:21:  reach
  06:21-06:22:  support,
  06:22-06:22:  et
  06:22-06:22:  cetera,
  06:22-06:22:  et
  06:22-06:23:  cetera.

[06:24 -> 06:40] If some of that information is missing from the answer, the answer would not be correct, but you need to be very specific about what exact information you need to see in the answer, and that information is very specific to that specific question.
  06:24-06:24:  If
  06:24-06:24:  some
  06:24-06:25:  of
  06:25-06:25:  that
  06:25-06:25:  information
  06:25-06:26:  is
  06:26-06:26:  missing
  06:26-06:26:  from
  06:26-06:27:  the
  06:27-06:27:  answer,
  06:28-06:28:  the
  06:28-06:28:  answer
  06:28-06:29:  would
  06:29-06:29:  not
  06:29-06:29:  be
  06:29-06:30:  correct,
  06:30-06:30:  but
  06:30-06:31:  you
  06:31-06:31:  need
  06:31-06:31:  to
  06:31-06:31:  be
  06:31-06:31:  very
  06:31-06:32:  specific
  06:32-06:32:  about
  06:32-06:33:  what
  06:33-06:34:  exact
  06:34-06:34:  information
  06:34-06:35:  you
  06:35-06:35:  need
  06:35-06:35:  to
  06:35-06:35:  see
  06:35-06:35:  in
  06:35-06:36:  the
  06:36-06:36:  answer,
  06:36-06:36:  and
  06:36-06:36:  that
  06:36-06:37:  information
  06:37-06:38:  is
  06:38-06:38:  very
  06:38-06:38:  specific
  06:38-06:38:  to
  06:38-06:39:  that
  06:39-06:39:  specific
  06:39-06:40:  question.

[06:40 -> 06:54] So you need to build lots of VALs from the materials, in this case, that mimic specific user questions that you need to label to answer for.
  06:40-06:40:  So
  06:40-06:40:  you
  06:40-06:41:  need
  06:41-06:41:  to
  06:41-06:41:  build
  06:41-06:42:  lots
  06:42-06:42:  of
  06:42-06:43:  VALs
  06:43-06:45:  from
  06:45-06:46:  the
  06:46-06:46:  materials,
  06:46-06:46:  in
  06:46-06:47:  this
  06:47-06:47:  case,
  06:47-06:48:  that
  06:48-06:48:  mimic
  06:48-06:49:  specific
  06:49-06:50:  user
  06:50-06:51:  questions
  06:51-06:52:  that
  06:52-06:52:  you
  06:52-06:53:  need
  06:53-06:53:  to
  06:53-06:53:  label
  06:53-06:53:  to
  06:53-06:54:  answer
  06:54-06:54:  for.

[06:55 -> 07:19] How do we do it usually? Again, I work with smart models like O3, and I provide it enough context, I provide it which personas are we trying to represent, because you can make ask the same question in completely different ways, depending on who is the persona asking, yet you would expect exactly the same answer, so you need to account for it.
  06:55-06:55:  How
  06:55-06:56:  do
  06:56-06:56:  we
  06:56-06:56:  do
  06:56-06:56:  it
  06:56-06:56:  usually?
  06:57-06:57:  Again,
  06:57-06:57:  I
  06:57-06:57:  work
  06:57-06:57:  with
  06:57-06:58:  smart
  06:58-06:59:  models
  06:59-06:59:  like
  06:59-06:59:  O3,
  07:00-07:01:  and
  07:01-07:01:  I
  07:01-07:02:  provide
  07:02-07:03:  it
  07:03-07:03:  enough
  07:03-07:03:  context,
  07:03-07:04:  I
  07:04-07:04:  provide
  07:04-07:04:  it
  07:04-07:05:  which
  07:05-07:05:  personas
  07:05-07:06:  are
  07:06-07:06:  we
  07:06-07:06:  trying
  07:06-07:06:  to
  07:06-07:07:  represent,
  07:07-07:08:  because
  07:08-07:08:  you
  07:08-07:08:  can
  07:08-07:08:  make
  07:08-07:09:  ask
  07:09-07:09:  the
  07:09-07:09:  same
  07:09-07:10:  question
  07:10-07:10:  in
  07:10-07:11:  completely
  07:11-07:11:  different
  07:11-07:12:  ways,
  07:12-07:13:  depending
  07:13-07:13:  on
  07:13-07:14:  who
  07:14-07:14:  is
  07:14-07:14:  the
  07:14-07:14:  persona
  07:14-07:15:  asking,
  07:16-07:16:  yet
  07:16-07:16:  you
  07:16-07:17:  would
  07:17-07:17:  expect
  07:17-07:17:  exactly
  07:17-07:18:  the
  07:18-07:18:  same
  07:18-07:18:  answer,
  07:18-07:18:  so
  07:18-07:19:  you
  07:19-07:19:  need
  07:19-07:19:  to
  07:19-07:19:  account
  07:19-07:19:  for
  07:19-07:19:  it.

[07:22 -> 07:46] So this is an example from the open source platform that we have that just helps to get it done, so if you look it up, I'm not trying to sell you anything, I'm not trying to vendor lock in or whatever, it's completely open source, and if needed, I can just recreate it in a couple of days now with cursor, the point is in the approach, not in the platform.
  07:22-07:23:  So
  07:23-07:23:  this
  07:23-07:23:  is
  07:23-07:24:  an
  07:24-07:25:  example
  07:25-07:25:  from
  07:25-07:26:  the
  07:26-07:26:  open
  07:26-07:26:  source
  07:26-07:27:  platform
  07:27-07:27:  that
  07:27-07:27:  we
  07:27-07:27:  have
  07:27-07:28:  that
  07:28-07:29:  just
  07:29-07:29:  helps
  07:29-07:29:  to
  07:29-07:30:  get
  07:30-07:30:  it
  07:30-07:30:  done,
  07:31-07:31:  so
  07:31-07:32:  if
  07:32-07:32:  you
  07:32-07:32:  look
  07:32-07:32:  it
  07:32-07:32:  up,
  07:32-07:33:  I'm
  07:33-07:33:  not
  07:33-07:34:  trying
  07:34-07:34:  to
  07:34-07:34:  sell
  07:34-07:34:  you
  07:34-07:35:  anything,
  07:35-07:35:  I'm
  07:35-07:35:  not
  07:35-07:35:  trying
  07:35-07:35:  to
  07:35-07:36:  vendor
  07:36-07:37:  lock
  07:37-07:37:  in
  07:37-07:37:  or
  07:37-07:37:  whatever,
  07:38-07:38:  it's
  07:38-07:38:  completely
  07:38-07:38:  open
  07:38-07:39:  source,
  07:39-07:40:  and
  07:40-07:40:  if
  07:40-07:41:  needed,
  07:41-07:41:  I
  07:41-07:41:  can
  07:41-07:41:  just
  07:41-07:42:  recreate
  07:42-07:42:  it
  07:42-07:42:  in
  07:42-07:42:  a
  07:42-07:42:  couple
  07:42-07:42:  of
  07:42-07:43:  days
  07:43-07:43:  now
  07:43-07:43:  with
  07:43-07:44:  cursor,
  07:44-07:44:  the
  07:44-07:45:  point
  07:45-07:45:  is
  07:45-07:45:  in
  07:45-07:45:  the
  07:45-07:45:  approach,
  07:45-07:46:  not
  07:46-07:46:  in
  07:46-07:46:  the
  07:46-07:46:  platform.

[07:47 -> 08:08] So for example here, we see that very same question, how do I reset my password, you see what was the input, what was the output, and that specific criteria that I measure it, that specific question, how do I know if the answer is correct.
  07:47-07:48:  So
  07:48-07:48:  for
  07:48-07:48:  example
  07:48-07:48:  here,
  07:49-07:49:  we
  07:49-07:49:  see
  07:49-07:49:  that
  07:49-07:50:  very
  07:50-07:50:  same
  07:50-07:51:  question,
  07:52-07:52:  how
  07:52-07:53:  do
  07:53-07:53:  I
  07:53-07:53:  reset
  07:53-07:53:  my
  07:53-07:53:  password,
  07:54-07:54:  you
  07:54-07:55:  see
  07:55-07:56:  what
  07:56-07:56:  was
  07:56-07:56:  the
  07:56-07:56:  input,
  07:57-07:57:  what
  07:57-07:57:  was
  07:57-07:57:  the
  07:57-07:57:  output,
  07:58-07:58:  and
  07:58-07:59:  that
  07:59-08:00:  specific
  08:00-08:01:  criteria
  08:01-08:01:  that
  08:01-08:01:  I
  08:01-08:02:  measure
  08:02-08:02:  it,
  08:03-08:04:  that
  08:04-08:05:  specific
  08:05-08:05:  question,
  08:06-08:06:  how
  08:06-08:06:  do
  08:06-08:06:  I
  08:06-08:06:  know
  08:06-08:07:  if
  08:07-08:07:  the
  08:07-08:07:  answer
  08:07-08:07:  is
  08:07-08:08:  correct.

[08:08 -> 08:22] And now I can just reiterate and generate like 50 different variations of the same question, and see if I still get the right answer, if the answer matches all the checklist that I have for that specific answer.
  08:08-08:08:  And
  08:08-08:09:  now
  08:09-08:09:  I
  08:09-08:10:  can
  08:10-08:10:  just
  08:10-08:10:  reiterate
  08:10-08:10:  and
  08:10-08:11:  generate
  08:11-08:11:  like
  08:11-08:12:  50
  08:12-08:13:  different
  08:13-08:13:  variations
  08:13-08:13:  of
  08:13-08:14:  the
  08:14-08:14:  same
  08:14-08:14:  question,
  08:14-08:15:  and
  08:15-08:15:  see
  08:15-08:15:  if
  08:15-08:15:  I
  08:15-08:16:  still
  08:16-08:17:  get
  08:17-08:17:  the
  08:17-08:17:  right
  08:17-08:17:  answer,
  08:18-08:18:  if
  08:18-08:18:  the
  08:18-08:19:  answer
  08:19-08:19:  matches
  08:19-08:19:  all
  08:19-08:20:  the
  08:20-08:20:  checklist
  08:20-08:21:  that
  08:21-08:21:  I
  08:21-08:21:  have
  08:21-08:21:  for
  08:21-08:22:  that
  08:22-08:22:  specific
  08:22-08:22:  answer.

[08:25 -> 08:36] How the process usually works, so contrary to regular approach, you build your evolves, not at the end of the process, but at the very beginning of the process.
  08:25-08:25:  How
  08:25-08:26:  the
  08:26-08:26:  process
  08:26-08:27:  usually
  08:27-08:27:  works,
  08:27-08:29:  so
  08:29-08:30:  contrary
  08:30-08:30:  to
  08:30-08:31:  regular
  08:31-08:31:  approach,
  08:32-08:32:  you
  08:32-08:32:  build
  08:32-08:32:  your
  08:32-08:32:  evolves,
  08:33-08:33:  not
  08:33-08:33:  at
  08:33-08:33:  the
  08:33-08:34:  end
  08:34-08:34:  of
  08:34-08:34:  the
  08:34-08:34:  process,
  08:35-08:35:  but
  08:35-08:35:  at
  08:35-08:35:  the
  08:35-08:35:  very
  08:35-08:36:  beginning
  08:36-08:36:  of
  08:36-08:36:  the
  08:36-08:36:  process.

[08:36 -> 08:54] So you just build your first version of the POC, you define a first version of your tests, evaluations, you run them, and you see what's going on, you will see that in some cases it will fail, in some cases it will succeed.
  08:36-08:37:  So
  08:37-08:37:  you
  08:37-08:38:  just
  08:38-08:38:  build
  08:38-08:39:  your
  08:39-08:39:  first
  08:39-08:39:  version
  08:39-08:40:  of
  08:40-08:40:  the
  08:40-08:41:  POC,
  08:42-08:42:  you
  08:42-08:43:  define
  08:43-08:43:  a
  08:43-08:44:  first
  08:44-08:44:  version
  08:44-08:44:  of
  08:44-08:44:  your
  08:44-08:45:  tests,
  08:45-08:46:  evaluations,
  08:46-08:47:  you
  08:47-08:47:  run
  08:47-08:47:  them,
  08:48-08:48:  and
  08:48-08:48:  you
  08:48-08:48:  see
  08:48-08:48:  what's
  08:48-08:48:  going
  08:48-08:49:  on,
  08:49-08:49:  you
  08:49-08:49:  will
  08:49-08:50:  see
  08:50-08:50:  that
  08:50-08:50:  in
  08:50-08:51:  some
  08:51-08:51:  cases
  08:51-08:51:  it
  08:51-08:51:  will
  08:51-08:52:  fail,
  08:52-08:53:  in
  08:53-08:53:  some
  08:53-08:53:  cases
  08:53-08:53:  it
  08:53-08:53:  will
  08:53-08:54:  succeed.

[08:54 -> 09:05] What's important is to look at the details, not just see the average numbers, the average numbers won't tell you anything, won't tell you how to improve it.
  08:54-08:55:  What's
  08:55-08:55:  important
  08:55-08:56:  is
  08:56-08:56:  to
  08:56-08:57:  look
  08:57-08:57:  at
  08:57-08:57:  the
  08:57-08:58:  details,
  08:58-08:58:  not
  08:58-08:58:  just
  08:58-08:58:  see
  08:58-08:59:  the
  08:59-08:59:  average
  08:59-08:59:  numbers,
  08:59-09:00:  the
  09:00-09:00:  average
  09:00-09:00:  numbers
  09:00-09:01:  won't
  09:01-09:01:  tell
  09:01-09:01:  you
  09:01-09:01:  anything,
  09:02-09:03:  won't
  09:03-09:04:  tell
  09:04-09:04:  you
  09:04-09:04:  how
  09:04-09:04:  to
  09:04-09:05:  improve
  09:05-09:05:  it.

[09:05 -> 09:15] If you actually look at the details of each evaluation, you'll see exactly why it's failing, it could be failing because your test is not defined correctly.
  09:05-09:05:  If
  09:05-09:06:  you
  09:06-09:06:  actually
  09:06-09:06:  look
  09:06-09:06:  at
  09:06-09:06:  the
  09:06-09:07:  details
  09:07-09:07:  of
  09:07-09:07:  each
  09:07-09:08:  evaluation,
  09:09-09:09:  you'll
  09:09-09:09:  see
  09:09-09:09:  exactly
  09:09-09:10:  why
  09:10-09:10:  it's
  09:10-09:10:  failing,
  09:10-09:11:  it
  09:11-09:11:  could
  09:11-09:11:  be
  09:11-09:11:  failing
  09:11-09:13:  because
  09:13-09:13:  your
  09:13-09:13:  test
  09:13-09:14:  is
  09:14-09:14:  not
  09:14-09:14:  defined
  09:14-09:15:  correctly.

[09:15 -> 09:36] It could be failing because your solution is not working as it should be, and in order to do it, you may need to do a change in your logic, you may change a prompt, or the data that you use in order to answer a question in our example.
  09:15-09:15:  It
  09:15-09:16:  could
  09:16-09:16:  be
  09:16-09:16:  failing
  09:16-09:16:  because
  09:16-09:17:  your
  09:17-09:17:  solution
  09:17-09:18:  is
  09:18-09:18:  not
  09:18-09:18:  working
  09:18-09:19:  as
  09:19-09:19:  it
  09:19-09:19:  should
  09:19-09:19:  be,
  09:20-09:20:  and
  09:20-09:21:  in
  09:21-09:21:  order
  09:21-09:22:  to
  09:22-09:22:  do
  09:22-09:22:  it,
  09:22-09:22:  you
  09:22-09:23:  may
  09:23-09:23:  need
  09:23-09:24:  to
  09:24-09:24:  do
  09:24-09:24:  a
  09:24-09:25:  change
  09:25-09:25:  in
  09:25-09:26:  your
  09:26-09:27:  logic,
  09:29-09:29:  you
  09:29-09:29:  may
  09:29-09:29:  change
  09:29-09:29:  a
  09:29-09:30:  prompt,
  09:31-09:31:  or
  09:31-09:31:  the
  09:31-09:31:  data
  09:31-09:32:  that
  09:32-09:32:  you
  09:32-09:32:  use
  09:32-09:32:  in
  09:32-09:32:  order
  09:32-09:33:  to
  09:33-09:34:  answer
  09:34-09:34:  a
  09:34-09:35:  question
  09:35-09:35:  in
  09:35-09:35:  our
  09:35-09:36:  example.

[09:38 -> 09:57] Basically, what you do now is experimentation, so you start running your experiment, you change something, you need to define these tests in a way that will help you to make an educated guess on what you need to change in order to do it, in some cases it will work, in some cases it won't.
  09:38-09:38:  Basically,
  09:39-09:39:  what
  09:39-09:39:  you
  09:39-09:39:  do
  09:39-09:39:  now
  09:39-09:39:  is
  09:39-09:40:  experimentation,
  09:40-09:40:  so
  09:40-09:41:  you
  09:41-09:41:  start
  09:41-09:42:  running
  09:42-09:42:  your
  09:42-09:42:  experiment,
  09:43-09:43:  you
  09:43-09:43:  change
  09:43-09:43:  something,
  09:44-09:44:  you
  09:44-09:45:  need
  09:45-09:45:  to
  09:45-09:45:  define
  09:45-09:46:  these
  09:46-09:46:  tests
  09:46-09:47:  in
  09:47-09:47:  a
  09:47-09:47:  way
  09:47-09:47:  that
  09:47-09:48:  will
  09:48-09:49:  help
  09:49-09:49:  you
  09:49-09:49:  to
  09:49-09:49:  make
  09:49-09:50:  an
  09:50-09:50:  educated
  09:50-09:51:  guess
  09:51-09:51:  on
  09:51-09:52:  what
  09:52-09:53:  you
  09:53-09:53:  need
  09:53-09:53:  to
  09:53-09:53:  change
  09:53-09:54:  in
  09:54-09:54:  order
  09:54-09:54:  to
  09:54-09:54:  do
  09:54-09:55:  it,
  09:55-09:55:  in
  09:55-09:56:  some
  09:56-09:56:  cases
  09:56-09:56:  it
  09:56-09:56:  will
  09:56-09:56:  work,
  09:56-09:57:  in
  09:57-09:57:  some
  09:57-09:57:  cases
  09:57-09:57:  it
  09:57-09:57:  won't.

[09:57 -> 10:18] But even if it works, let's say you change something in your prompt, and it fixed this test. In my experience, in many cases it breaks something that used to work before, you have constant regressions, and if you don't have these evaluations, there's no way you'll be able to catch it on time.
  09:57-09:58:  But
  09:58-09:58:  even
  09:58-09:58:  if
  09:58-09:58:  it
  09:58-09:59:  works,
  10:00-10:01:  let's
  10:01-10:01:  say
  10:01-10:01:  you
  10:01-10:01:  change
  10:01-10:02:  something
  10:02-10:02:  in
  10:02-10:02:  your
  10:02-10:02:  prompt,
  10:03-10:03:  and
  10:03-10:03:  it
  10:03-10:03:  fixed
  10:03-10:04:  this
  10:04-10:04:  test.
  10:05-10:05:  In
  10:05-10:05:  my
  10:05-10:06:  experience,
  10:06-10:06:  in
  10:06-10:06:  many
  10:06-10:06:  cases
  10:06-10:07:  it
  10:07-10:07:  breaks
  10:07-10:08:  something
  10:08-10:08:  that
  10:08-10:08:  used
  10:08-10:09:  to
  10:09-10:09:  work
  10:09-10:09:  before,
  10:10-10:11:  you
  10:11-10:12:  have
  10:12-10:12:  constant
  10:12-10:13:  regressions,
  10:13-10:14:  and
  10:14-10:14:  if
  10:14-10:14:  you
  10:14-10:14:  don't
  10:14-10:15:  have
  10:15-10:15:  these
  10:15-10:15:  evaluations,
  10:16-10:16:  there's
  10:16-10:16:  no
  10:16-10:16:  way
  10:16-10:16:  you'll
  10:16-10:17:  be
  10:17-10:17:  able
  10:17-10:17:  to
  10:17-10:17:  catch
  10:17-10:17:  it
  10:17-10:17:  on
  10:17-10:18:  time.

[10:18 -> 10:45] So this is hugely important, and what actually happens is that, again, you build your first version, you build your first version of the evals, you match them, you run these evals, you improve something, you improve your evals, or maybe add more evaluations, and then you continuously improve it until you reach some point where you are satisfied with your evals, for this specific solution, for that specific point of time.
  10:18-10:18:  So
  10:18-10:20:  this
  10:20-10:20:  is
  10:20-10:20:  hugely
  10:20-10:21:  important,
  10:21-10:21:  and
  10:21-10:21:  what
  10:21-10:22:  actually
  10:22-10:23:  happens
  10:23-10:23:  is
  10:23-10:23:  that,
  10:23-10:23:  again,
  10:23-10:24:  you
  10:24-10:24:  build
  10:24-10:24:  your
  10:24-10:24:  first
  10:24-10:25:  version,
  10:25-10:25:  you
  10:25-10:25:  build
  10:25-10:26:  your
  10:26-10:26:  first
  10:26-10:26:  version
  10:26-10:26:  of
  10:26-10:26:  the
  10:26-10:27:  evals,
  10:27-10:28:  you
  10:28-10:28:  match
  10:28-10:28:  them,
  10:28-10:28:  you
  10:28-10:29:  run
  10:29-10:29:  these
  10:29-10:29:  evals,
  10:29-10:30:  you
  10:30-10:30:  improve
  10:30-10:30:  something,
  10:30-10:30:  you
  10:30-10:31:  improve
  10:31-10:31:  your
  10:31-10:31:  evals,
  10:31-10:31:  or
  10:31-10:32:  maybe
  10:32-10:32:  add
  10:32-10:32:  more
  10:32-10:33:  evaluations,
  10:34-10:34:  and
  10:34-10:34:  then
  10:34-10:34:  you
  10:34-10:35:  continuously
  10:35-10:36:  improve
  10:36-10:36:  it
  10:36-10:37:  until
  10:37-10:37:  you
  10:37-10:37:  reach
  10:37-10:38:  some
  10:38-10:39:  point
  10:39-10:39:  where
  10:39-10:39:  you
  10:39-10:39:  are
  10:39-10:40:  satisfied
  10:40-10:41:  with
  10:41-10:41:  your
  10:41-10:41:  evals,
  10:42-10:42:  for
  10:42-10:42:  this
  10:42-10:43:  specific
  10:43-10:43:  solution,
  10:43-10:43:  for
  10:43-10:44:  that
  10:44-10:44:  specific
  10:44-10:44:  point
  10:44-10:44:  of
  10:44-10:45:  time.

[10:46 -> 11:10] And what actually happened is that you got your baseline, you got your benchmark, that now you can start optimizing, and you have the confidence that the tests should be working, so now you can try another model, let's say, well, what, how can I try to see if Foro Mini will work the same way with Foro, or not?
  10:46-10:46:  And
  10:46-10:47:  what
  10:47-10:47:  actually
  10:47-10:48:  happened
  10:48-10:48:  is
  10:48-10:48:  that
  10:48-10:48:  you
  10:48-10:49:  got
  10:49-10:49:  your
  10:49-10:50:  baseline,
  10:50-10:50:  you
  10:50-10:50:  got
  10:50-10:50:  your
  10:50-10:51:  benchmark,
  10:51-10:51:  that
  10:51-10:52:  now
  10:52-10:52:  you
  10:52-10:53:  can
  10:53-10:53:  start
  10:53-10:54:  optimizing,
  10:54-10:55:  and
  10:55-10:56:  you
  10:56-10:56:  have
  10:56-10:56:  the
  10:56-10:57:  confidence
  10:57-10:58:  that
  10:58-10:58:  the
  10:58-10:58:  tests
  10:58-10:59:  should
  10:59-10:59:  be
  10:59-11:00:  working,
  11:00-11:00:  so
  11:00-11:00:  now
  11:00-11:01:  you
  11:01-11:01:  can
  11:01-11:01:  try
  11:01-11:01:  another
  11:01-11:02:  model,
  11:02-11:02:  let's
  11:02-11:02:  say,
  11:03-11:03:  well,
  11:03-11:03:  what,
  11:04-11:04:  how
  11:04-11:04:  can
  11:04-11:04:  I
  11:04-11:05:  try
  11:05-11:05:  to
  11:05-11:05:  see
  11:05-11:06:  if
  11:06-11:06:  Foro
  11:06-11:06:  Mini
  11:06-11:07:  will
  11:07-11:08:  work
  11:08-11:08:  the
  11:08-11:08:  same
  11:08-11:09:  way
  11:09-11:09:  with
  11:09-11:09:  Foro,
  11:10-11:10:  or
  11:10-11:10:  not?

[11:11 -> 11:33] Can I use the graph rag, or can I try a simpler solution? Should I have to use the agentic approach that maybe better, but requires more time, more inference costs, etc., or should they try to simplify the logic, or maybe I can simplify the logic for a specific portion of the application, etc., etc.
  11:11-11:12:  Can
  11:12-11:12:  I
  11:12-11:12:  use
  11:12-11:12:  the
  11:12-11:12:  graph
  11:12-11:13:  rag,
  11:13-11:13:  or
  11:13-11:13:  can
  11:13-11:13:  I
  11:13-11:13:  try
  11:13-11:14:  a
  11:14-11:14:  simpler
  11:14-11:14:  solution?
  11:15-11:16:  Should
  11:16-11:16:  I
  11:16-11:16:  have
  11:16-11:17:  to
  11:17-11:17:  use
  11:17-11:18:  the
  11:18-11:18:  agentic
  11:18-11:18:  approach
  11:18-11:19:  that
  11:19-11:21:  maybe
  11:21-11:22:  better,
  11:22-11:22:  but
  11:22-11:23:  requires
  11:23-11:24:  more
  11:24-11:24:  time,
  11:24-11:25:  more
  11:25-11:26:  inference
  11:26-11:26:  costs,
  11:26-11:26:  etc.,
  11:26-11:27:  or
  11:27-11:27:  should
  11:27-11:27:  they
  11:27-11:27:  try
  11:27-11:27:  to
  11:27-11:28:  simplify
  11:28-11:28:  the
  11:28-11:28:  logic,
  11:28-11:28:  or
  11:28-11:29:  maybe
  11:29-11:29:  I
  11:29-11:29:  can
  11:29-11:29:  simplify
  11:29-11:29:  the
  11:29-11:30:  logic
  11:30-11:30:  for
  11:30-11:31:  a
  11:31-11:31:  specific
  11:31-11:31:  portion
  11:31-11:32:  of
  11:32-11:32:  the
  11:32-11:32:  application,
  11:33-11:33:  etc.,
  11:33-11:33:  etc.

[11:33 -> 12:01] Having this benchmark allows you to do all visit to limitations with confidence, but again, the most important part is how do you reach this benchmark, and while the approach is pretty much the same, the evaluations that you need to build, and how do you build your evaluations are completely different depending on the solution that you need to build, because the models are super capable right now,
  11:33-11:34:  Having
  11:34-11:35:  this
  11:35-11:35:  benchmark
  11:35-11:37:  allows
  11:37-11:37:  you
  11:37-11:37:  to
  11:37-11:37:  do
  11:37-11:38:  all
  11:38-11:38:  visit
  11:38-11:38:  to
  11:38-11:39:  limitations
  11:39-11:40:  with
  11:40-11:40:  confidence,
  11:40-11:41:  but
  11:41-11:41:  again,
  11:41-11:41:  the
  11:41-11:42:  most
  11:42-11:42:  important
  11:42-11:42:  part
  11:42-11:42:  is
  11:42-11:43:  how
  11:43-11:43:  do
  11:43-11:43:  you
  11:43-11:44:  reach
  11:44-11:44:  this
  11:44-11:44:  benchmark,
  11:45-11:46:  and
  11:46-11:47:  while
  11:47-11:47:  the
  11:47-11:47:  approach
  11:47-11:48:  is
  11:48-11:49:  pretty
  11:49-11:49:  much
  11:49-11:50:  the
  11:50-11:50:  same,
  11:50-11:51:  the
  11:51-11:51:  evaluations
  11:51-11:52:  that
  11:52-11:52:  you
  11:52-11:52:  need
  11:52-11:52:  to
  11:52-11:52:  build,
  11:52-11:52:  and
  11:52-11:53:  how
  11:53-11:53:  do
  11:53-11:53:  you
  11:53-11:53:  build
  11:53-11:53:  your
  11:53-11:54:  evaluations
  11:54-11:54:  are
  11:54-11:54:  completely
  11:54-11:55:  different
  11:55-11:55:  depending
  11:55-11:55:  on
  11:55-11:56:  the
  11:56-11:57:  solution
  11:57-11:57:  that
  11:57-11:57:  you
  11:57-11:57:  need
  11:57-11:57:  to
  11:57-11:58:  build,
  11:58-11:59:  because
  11:59-11:59:  the
  11:59-11:59:  models
  11:59-12:00:  are
  12:00-12:00:  super
  12:00-12:01:  capable
  12:01-12:01:  right
  12:01-12:01:  now,

[12:01 -> 12:11] so they allow you to build a huge variety of solutions, but each and every solution is quite different in terms of how do you evaluate it.
  12:01-12:02:  so
  12:02-12:02:  they
  12:02-12:03:  allow
  12:03-12:03:  you
  12:03-12:03:  to
  12:03-12:03:  build
  12:03-12:04:  a
  12:04-12:04:  huge
  12:04-12:04:  variety
  12:04-12:05:  of
  12:05-12:05:  solutions,
  12:06-12:06:  but
  12:06-12:07:  each
  12:07-12:07:  and
  12:07-12:07:  every
  12:07-12:07:  solution
  12:07-12:08:  is
  12:08-12:08:  quite
  12:08-12:09:  different
  12:09-12:09:  in
  12:09-12:09:  terms
  12:09-12:09:  of
  12:09-12:10:  how
  12:10-12:10:  do
  12:10-12:10:  you
  12:10-12:11:  evaluate
  12:11-12:11:  it.

[12:12 -> 12:28] For support bot, you usually typically use lm as a judge, as an example. If your building takes to a scale, or takes to graph database, then to my experience the best way is to create a mock database that represents
  12:12-12:12:  For
  12:12-12:12:  support
  12:12-12:13:  bot,
  12:13-12:13:  you
  12:13-12:14:  usually
  12:14-12:14:  typically
  12:14-12:15:  use
  12:15-12:15:  lm
  12:15-12:15:  as
  12:15-12:15:  a
  12:15-12:15:  judge,
  12:16-12:16:  as
  12:16-12:16:  an
  12:16-12:17:  example.
  12:18-12:18:  If
  12:18-12:19:  your
  12:19-12:19:  building
  12:19-12:19:  takes
  12:19-12:19:  to
  12:19-12:20:  a
  12:20-12:20:  scale,
  12:20-12:20:  or
  12:20-12:20:  takes
  12:20-12:21:  to
  12:21-12:21:  graph
  12:21-12:21:  database,
  12:22-12:22:  then
  12:22-12:23:  to
  12:23-12:23:  my
  12:23-12:23:  experience
  12:23-12:23:  the
  12:23-12:24:  best
  12:24-12:24:  way
  12:24-12:25:  is
  12:25-12:25:  to
  12:25-12:25:  create
  12:25-12:25:  a
  12:25-12:25:  mock
  12:25-12:26:  database
  12:26-12:26:  that
  12:26-12:28:  represents

[12:30 -> 12:42] whatever database or databases that you need your solution to work with, represent the same schema, and you have the mock data, so you know exactly what to expect on specific questions.
  12:30-12:31:  whatever
  12:31-12:31:  database
  12:31-12:31:  or
  12:31-12:32:  databases
  12:32-12:32:  that
  12:32-12:32:  you
  12:32-12:33:  need
  12:33-12:34:  your
  12:34-12:34:  solution
  12:34-12:34:  to
  12:34-12:35:  work
  12:35-12:35:  with,
  12:35-12:36:  represent
  12:36-12:36:  the
  12:36-12:36:  same
  12:36-12:36:  schema,
  12:36-12:36:  and
  12:36-12:37:  you
  12:37-12:37:  have
  12:37-12:37:  the
  12:37-12:37:  mock
  12:37-12:37:  data,
  12:38-12:38:  so
  12:38-12:38:  you
  12:38-12:38:  know
  12:38-12:39:  exactly
  12:39-12:40:  what
  12:40-12:40:  to
  12:40-12:41:  expect
  12:41-12:41:  on
  12:41-12:42:  specific
  12:42-12:42:  questions.

[12:43 -> 12:53] If you need to build some classifier for call center conversations, then your tests are simple much, whenever this is the right rubric or not.
  12:43-12:44:  If
  12:44-12:44:  you
  12:44-12:44:  need
  12:44-12:44:  to
  12:44-12:45:  build
  12:45-12:45:  some
  12:45-12:45:  classifier
  12:45-12:46:  for
  12:46-12:46:  call
  12:46-12:46:  center
  12:46-12:47:  conversations,
  12:47-12:47:  then
  12:47-12:48:  your
  12:48-12:49:  tests
  12:49-12:49:  are
  12:49-12:50:  simple
  12:50-12:51:  much,
  12:51-12:51:  whenever
  12:51-12:51:  this
  12:51-12:51:  is
  12:51-12:52:  the
  12:52-12:52:  right
  12:52-12:52:  rubric
  12:52-12:52:  or
  12:52-12:53:  not.

[12:54 -> 13:21] And this approach applies to guardrails, so getting back to the example of customer support bot, guardrails you need to cover questions that should not be answered, or questions that should be answered in different ways, or questions that the answers are not in the material, so all of these you can put into your benchmark, just different type of benchmark, but it's pretty much the same approach.
  12:54-12:54:  And
  12:54-12:54:  this
  12:54-12:55:  approach
  12:55-12:56:  applies
  12:56-12:56:  to
  12:56-12:57:  guardrails,
  12:57-12:57:  so
  12:57-12:59:  getting
  12:59-12:59:  back
  12:59-12:59:  to
  12:59-12:59:  the
  12:59-13:01:  example
  13:01-13:01:  of
  13:01-13:02:  customer
  13:02-13:02:  support
  13:02-13:02:  bot,
  13:03-13:04:  guardrails
  13:04-13:04:  you
  13:04-13:05:  need
  13:05-13:05:  to
  13:05-13:05:  cover
  13:05-13:06:  questions
  13:06-13:07:  that
  13:07-13:07:  should
  13:07-13:07:  not
  13:07-13:08:  be
  13:08-13:08:  answered,
  13:08-13:08:  or
  13:08-13:09:  questions
  13:09-13:09:  that
  13:09-13:09:  should
  13:09-13:09:  be
  13:09-13:10:  answered
  13:10-13:10:  in
  13:10-13:10:  different
  13:10-13:11:  ways,
  13:11-13:11:  or
  13:11-13:11:  questions
  13:11-13:11:  that
  13:11-13:12:  the
  13:12-13:13:  answers
  13:13-13:13:  are
  13:13-13:14:  not
  13:14-13:14:  in
  13:14-13:14:  the
  13:14-13:14:  material,
  13:15-13:15:  so
  13:15-13:15:  all
  13:15-13:15:  of
  13:15-13:15:  these
  13:15-13:16:  you
  13:16-13:16:  can
  13:16-13:16:  put
  13:16-13:17:  into
  13:17-13:17:  your
  13:17-13:17:  benchmark,
  13:17-13:17:  just
  13:17-13:18:  different
  13:18-13:18:  type
  13:18-13:19:  of
  13:19-13:19:  benchmark,
  13:19-13:19:  but
  13:19-13:19:  it's
  13:19-13:20:  pretty
  13:20-13:20:  much
  13:20-13:20:  the
  13:20-13:20:  same
  13:20-13:21:  approach.

[13:23 -> 13:38] So just to reiterate the key takeaways, you need to evaluate your apps the way your users actually use them, and avoid abstract metrics, because these abstract vectors don't really measure anything important.
  13:23-13:24:  So
  13:24-13:24:  just
  13:24-13:24:  to
  13:24-13:25:  reiterate
  13:25-13:26:  the
  13:26-13:26:  key
  13:26-13:26:  takeaways,
  13:27-13:27:  you
  13:27-13:27:  need
  13:27-13:27:  to
  13:27-13:28:  evaluate
  13:28-13:28:  your
  13:28-13:28:  apps
  13:28-13:28:  the
  13:28-13:28:  way
  13:28-13:29:  your
  13:29-13:29:  users
  13:29-13:30:  actually
  13:30-13:30:  use
  13:30-13:30:  them,
  13:31-13:32:  and
  13:32-13:33:  avoid
  13:33-13:33:  abstract
  13:33-13:34:  metrics,
  13:34-13:35:  because
  13:35-13:36:  these
  13:36-13:36:  abstract
  13:36-13:36:  vectors
  13:36-13:37:  don't
  13:37-13:37:  really
  13:37-13:37:  measure
  13:37-13:38:  anything
  13:38-13:38:  important.

[13:39 -> 14:07] And the approach is for experimentation, so you run these evaluations frequently, that allows you to have rapid progress with less regressions, because testing frequently helps you to catch with surprises, but most importantly what you get, if you define your evaluations correctly, you get your solution pretty much as kind of explainable AI, because you know exactly what it does,
  13:39-13:39:  And
  13:39-13:40:  the
  13:40-13:40:  approach
  13:40-13:41:  is
  13:41-13:41:  for
  13:41-13:42:  experimentation,
  13:42-13:42:  so
  13:42-13:42:  you
  13:42-13:42:  run
  13:42-13:43:  these
  13:43-13:43:  evaluations
  13:43-13:44:  frequently,
  13:44-13:45:  that
  13:45-13:45:  allows
  13:45-13:45:  you
  13:45-13:46:  to
  13:46-13:46:  have
  13:46-13:47:  rapid
  13:47-13:47:  progress
  13:47-13:48:  with
  13:48-13:48:  less
  13:48-13:49:  regressions,
  13:50-13:50:  because
  13:50-13:51:  testing
  13:51-13:52:  frequently
  13:52-13:52:  helps
  13:52-13:52:  you
  13:52-13:53:  to
  13:53-13:53:  catch
  13:53-13:53:  with
  13:53-13:54:  surprises,
  13:54-13:55:  but
  13:55-13:55:  most
  13:55-13:56:  importantly
  13:56-13:56:  what
  13:56-13:56:  you
  13:56-13:57:  get,
  13:57-13:58:  if
  13:58-13:58:  you
  13:58-13:59:  define
  13:59-13:59:  your
  13:59-13:59:  evaluations
  13:59-14:00:  correctly,
  14:00-14:00:  you
  14:00-14:01:  get
  14:01-14:01:  your
  14:01-14:02:  solution
  14:02-14:02:  pretty
  14:02-14:02:  much
  14:02-14:03:  as
  14:03-14:04:  kind
  14:04-14:04:  of
  14:04-14:05:  explainable
  14:05-14:05:  AI,
  14:06-14:06:  because
  14:06-14:06:  you
  14:06-14:06:  know
  14:06-14:06:  exactly
  14:06-14:07:  what
  14:07-14:07:  it
  14:07-14:07:  does,

[14:07 -> 14:10] you know exactly how it does it, if you test it the right way.
  14:07-14:07:  you
  14:07-14:07:  know
  14:07-14:08:  exactly
  14:08-14:08:  how
  14:08-14:08:  it
  14:08-14:08:  does
  14:08-14:09:  it,
  14:09-14:10:  if
  14:10-14:10:  you
  14:10-14:10:  test
  14:10-14:10:  it
  14:10-14:10:  the
  14:10-14:10:  right
  14:10-14:10:  way.

[14:13 -> 14:25] Thank you very much, take a look at Multinear, that's a platform that you can use to run these evaluations, you can totally use any other platform.
  14:13-14:13:  Thank
  14:13-14:13:  you
  14:13-14:13:  very
  14:13-14:14:  much,
  14:14-14:16:  take
  14:16-14:16:  a
  14:16-14:16:  look
  14:16-14:16:  at
  14:16-14:17:  Multinear,
  14:18-14:19:  that's
  14:19-14:19:  a
  14:19-14:20:  platform
  14:20-14:20:  that
  14:20-14:20:  you
  14:20-14:20:  can
  14:20-14:21:  use
  14:21-14:21:  to
  14:21-14:22:  run
  14:22-14:22:  these
  14:22-14:22:  evaluations,
  14:23-14:23:  you
  14:23-14:24:  can
  14:24-14:24:  totally
  14:24-14:24:  use
  14:24-14:25:  any
  14:25-14:25:  other
  14:25-14:25:  platform.

[14:25 -> 14:39] The approach is quite simple, it doesn't require any specific platform, I built Multinear just because no other platform helped me to do it this way, to help me with the process of evaluation like end to end.
  14:25-14:25:  The
  14:25-14:26:  approach
  14:26-14:26:  is
  14:26-14:27:  quite
  14:27-14:28:  simple,
  14:28-14:28:  it
  14:28-14:28:  doesn't
  14:28-14:28:  require
  14:28-14:29:  any
  14:29-14:29:  specific
  14:29-14:30:  platform,
  14:30-14:31:  I
  14:31-14:31:  built
  14:31-14:32:  Multinear
  14:32-14:32:  just
  14:32-14:32:  because
  14:32-14:33:  no
  14:33-14:34:  other
  14:34-14:34:  platform
  14:34-14:35:  helped
  14:35-14:35:  me
  14:35-14:35:  to
  14:35-14:35:  do
  14:35-14:35:  it
  14:35-14:36:  this
  14:36-14:36:  way,
  14:36-14:37:  to
  14:37-14:37:  help
  14:37-14:37:  me
  14:37-14:37:  with
  14:37-14:37:  the
  14:37-14:38:  process
  14:38-14:38:  of
  14:38-14:38:  evaluation
  14:38-14:39:  like
  14:39-14:39:  end
  14:39-14:39:  to
  14:39-14:39:  end.

[14:41 -> 14:48] I'm working on a startup that does reliable AI automation right now, and yeah, thank you very much.
  14:41-14:41:  I'm
  14:41-14:42:  working
  14:42-14:42:  on
  14:42-14:42:  a
  14:42-14:42:  startup
  14:42-14:43:  that
  14:43-14:43:  does
  14:43-14:43:  reliable
  14:43-14:44:  AI
  14:44-14:44:  automation
  14:44-14:44:  right
  14:44-14:45:  now,
  14:45-14:46:  and
  14:46-14:47:  yeah,
  14:47-14:48:  thank
  14:48-14:48:  you
  14:48-14:48:  very
  14:48-14:48:  much.

